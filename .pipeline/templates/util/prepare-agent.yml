steps:
  - script: |

  distro_name=""
  distro_version=""
  distro_name_version=""
  error()
  {
      echo 1>&2 "ERROR: $${@}"
  }

  get_distro_name()
  {
      typeset -g distro_name

      if [[ -z "$${distro_name:-}" ]]; then
          distro_name="$(. /etc/os-release; echo "$${ID,,}")"
      fi

      echo "$${distro_name}"
  }

  get_distro_version()
  {
      typeset -g distro_version

      if [[ -z "$${distro_version:-}" ]]; then
          distro_version="$(. /etc/os-release; echo "$${VERSION_ID,,}")"
      fi

      echo "$${distro_version}"
  }

  get_distro_name_version()
  {
      typeset -g distro_name_version

      if [[ -z "$${distro_name_version:-}" ]]; then
          distro_name_version="$(get_distro_name)_$(get_distro_version)"
      fi

      echo "$${distro_name_version}"
  }

  #
  # Package Management Functions
  #
  pkg_mgr_init()
  {
      typeset -g pkg_mgr

      case "$(get_distro_name)" in
      (ubuntu|debian)
          pkg_mgr="apt-get"
          ;;
      (sles|opensuse*)
          pkg_mgr="zypper"
          ;;
      (*)
          error "Unsupported distibution: '$${distro_name}'"
          exit 1
          ;;
      esac
  }

  pkg_mgr_refresh()
  {
      typeset -g pkg_mgr pkg_mgr_refreshed

      if [[ -z "$${pkg_mgr:-}" ]]; then
          pkg_mgr_init
      fi

      if [[ -n "$${pkg_mgr_refreshed:-}" ]]; then
          return
      fi

      case "$${pkg_mgr}" in
      (apt-get)
          sudo $${pkg_mgr} update --quiet
          ;;
      (zypper)
          sudo $${pkg_mgr} --gpg-auto-import-keys --quiet refresh 
          ;;
      esac

      pkg_mgr_refreshed=true
  }

  pkg_mgr_install()
  {
      typeset -g pkg_mgr

      pkg_mgr_refresh

      case "$${pkg_mgr}" in
      (apt-get)
          sudo env DEBIAN_FRONTEND=noninteractive $${pkg_mgr} --quiet --yes install "$${@}"
          ;;
      (zypper)
          sudo $${pkg_mgr} --gpg-auto-import-keys --quiet --non-interactive install --no-confirm "$${@}"
          ;;
      esac
  }

      echo "=== Install fixed version of Terraform ==="
      wget -q https://releases.hashicorp.com/terraform/0.14.7/terraform_0.14.7_linux_amd64.zip
      unzip terraform_0.14.7_linux_amd64.zip -d terraform_0.14.7/
      sudo mv terraform_0.14.7/terraform /usr/local/bin/terraform

      ansible_version="$${ansible_version:-2.9}"
      ansible_major="$${ansible_version%%.*}"
      ansible_minor=$(echo "$${ansible_version}." | cut -d . -f 2)

      # Ansible installation directories
      ansible_base=/opt/ansible
      ansible_bin=$${ansible_base}/bin
      ansible_venv=$${ansible_base}/venv/$${ansible_version}
      ansible_venv_bin=$${ansible_venv}/bin
      ansible_collections=$${ansible_base}/collections
      ansible_pip3=$${ansible_venv_bin}/pip3

      case "$(get_distro_name_version)" in
      (sles_12*)
          error "Unsupported distro: $${distro_name_version} doesn't provide virtualenv in standard repos."
          exit 1
          ;;
      (ubuntu*|sles*)
          echo "$${distro_name_version} is supported."
          ;;
      (*)
          error "Unsupported distro: $${distro_name_version} not currently supported."
          exit 1
          ;;
      esac

      # List of required packages whose names are common to all supported distros
      required_pkgs=(
          jq
          unzip
      )

      # Include distro version agnostic packages into required packages list
      case "$(get_distro_name)" in
      (ubuntu|sles)
          required_pkgs+=(
              python3-pip
              python3-virtualenv
          )
          ;;
      esac

      # Include distro version specific packages into required packages list
      case "$(get_distro_name_version)" in
      (ubuntu_18.04)
          required_pkgs+=(
              virtualenv
          )
          ;;
      esac

      # Ensure our package metadata cache is up to date
      pkg_mgr_refresh

      # Install required packages as determined above
      pkg_mgr_install "$${required_pkgs[@]}"

      #
      # Install latest Ansible revision of specified version for all users.
      #
      sudo mkdir -p \
          $${ansible_bin} \
          $${ansible_collections}

      # Create a Python3 based venv into which we will install Ansible.
      if [[ ! -e "$${ansible_venv_bin}/activate" ]]; then
          sudo rm -rf $${ansible_venv}
          sudo virtualenv --python python3 $${ansible_venv}
      fi

      # Fail if pip3 doesn't exist in the venv
      if [[ ! -x "$${ansible_venv_bin}/pip3" ]]; then
          echo "Using the wrong pip3: '$${found_pip3}' != '$${ansible_venv_bin}/pip3'"
          exit 1
      fi

      # Ensure that standard tools are up to date
      sudo $${ansible_venv_bin}/pip3 install --upgrade \
          pip \
          wheel \
          setuptools

      # Install latest MicroSoft Authentication Library
      # TODO(rtamalin): Do we need this? In particular do we expect to integrated
      # Rust based tools with the Python/Ansible envs that we are using?
      sudo $${ansible_venv_bin}/pip3 install \
          setuptools-rust

      # Install latest revision of target Ansible version, along with additional
      # useful/supporting Python packages such as ansible-lint, yamllint,
      # argcomplete, pywinrm.
      sudo $${ansible_venv_bin}/pip3 install \
          "ansible>=$${ansible_major}.$${ansible_minor},<$${ansible_major}.$((ansible_minor + 1))" \
          ansible-lint \
          argcomplete \
          'pywinrm>=0.3.0' \
          yamllint \
          msal

      # Install Ansible collections under the ANSIBLE_COLLECTIONS_PATHS for all users.
      sudo mkdir -p $${ansible_collections}
      sudo -H $${ansible_venv_bin}/ansible-galaxy collection install azure.azcollection --force --collections-path $${ansible_collections}

      # Install the Python requirements associated with the Ansible Azure collection
      # that was just installed into the Ansible venv.
      azure_azcollection_version=$(jq -r '.collection_info.version' $${ansible_collections}/ansible_collections/azure/azcollection/MANIFEST.json)
      wget -nv -O /tmp/requirements-azure.txt https://raw.githubusercontent.com/ansible-collections/azure/v$${azure_azcollection_version}/requirements-azure.txt
      sudo $${ansible_venv_bin}/pip3 install \
          -r /tmp/requirements-azure.txt

      # Create symlinks for all relevant commands that were installed in the Ansible
      # venv's bin so that they are available in the /opt/ansible/bin directory, which
      # will be added to the system PATH. This ensures that we expose only those tools
      # that we need from the Ansible venv bin directory without superceding standard
      # system versions of the commands that are also found there, e.g. python3.
      ansible_venv_commands=(
          # Ansible 2.9 command set
          ansible
          ansible-config
          ansible-connection
          ansible-console
          ansible-doc
          ansible-galaxy
          ansible-inventory
          ansible-playbook
          ansible-pull
          ansible-test
          ansible-vault

          # ansible-lint
          ansible-lint

          # argcomplete
          activate-global-python-argcomplete

          # yamllint
          yamllint
      )

      relative_path="$(realpath --relative-to $${ansible_bin} $${ansible_venv_bin})"
      for vcmd in "$${ansible_venv_commands[@]}"
      do
          sudo ln -vfs $${relative_path}/$${vcmd} $${ansible_bin}/$${vcmd}
      done

      # Ensure that Python argcomplete is enabled for all users interactive shell sessions
      sudo $${ansible_bin}/activate-global-python-argcomplete

      # Set env for ansible
      echo export ANSIBLE_HOST_KEY_CHECKING=False | sudo tee -a /etc/profile.d/deploy_server.sh
      echo export ANSIBLE_COLLECTIONS_PATHS=$${ansible_collections} | sudo tee -a /etc/profile.d/deploy_server.sh


      terraform --version

      echo "=== Set SSH keypair ==="
      mkdir -p $HOME/.ssh
      echo -e "$(hana-pipeline-rsa)" > $HOME/.ssh/id_rsa
      echo -e "$(hana-pipeline-rsa-pub)" > $HOME/.ssh/id_rsa.pub
      chmod 400 $HOME/.ssh/id_rsa

      echo "=== Set agent IP ==="
      echo '##vso[task.setvariable variable=agent_ip]$(curl -s https://ipinfo.io/json | jq -r .ip)'
    displayName: "Pre deployment"
